# local variable

class A {
  public int b() {
    int c = 5;
  }
}

==>

Program(
  ClassDeclaration(class,
    Definition,
    ClassBody(
      MethodDeclaration(
        Modifiers(public),
        PrimitiveType,
        Definition,
        FormalParameters,
        Block(
          LocalVariableDeclaration(
            PrimitiveType,
            VariableDeclarator(
              Definition,
              AssignOp,
              IntegerLiteral)))))))


# local array variable

String[] nodeNames = internalCluster().getNodeNames();
Integer[][] inputArrays = new Integer[0x100][];

==>

Program(
  LocalVariableDeclaration(
    ArrayType(
      TypeName,
      Dimension),
    VariableDeclarator(
      Definition,
      AssignOp,
      MethodInvocation(
        MethodInvocation(
          MethodName(Identifier),
          ArgumentList),
        MethodName(Identifier),
        ArgumentList))),
  LocalVariableDeclaration(
    ArrayType(
      TypeName,
      Dimension, Dimension),
    VariableDeclarator(
      Definition,
      AssignOp,
      ArrayCreationExpression(new,
        TypeName,
        Dimension(IntegerLiteral),
        Dimension))))


# module

module com.foo { }
open module com.foo { }

==>

Program(
  ModuleDeclaration(module,
    ScopedIdentifier(
      Identifier,
      Identifier),
    ModuleBody),
  ModuleDeclaration(open, module,
    ScopedIdentifier(
      Identifier,
      Identifier),
    ModuleBody))


# module with normal annotation

@RequestForEnhancement(
    id       = 2868724,
    synopsis = "Provide time-travel functionality",
    engineer = "Mr. Peabody",
    date     = "4/1/2004"
)
module com.foo { }

==>

Program(
  ModuleDeclaration(
    Annotation(
      Identifier,
      AnnotationArgumentList(
        ElementValuePair(Identifier, AssignOp, IntegerLiteral),
        ElementValuePair(Identifier, AssignOp, StringLiteral),
        ElementValuePair(Identifier, AssignOp, StringLiteral),
        ElementValuePair(Identifier, AssignOp, StringLiteral))),
    module,
    ScopedIdentifier(Identifier, Identifier),
    ModuleBody))


# module with marker annotation

@Preliminary module com.foo { }
@Preliminary open module com.foo { }

==>

Program(
  ModuleDeclaration(
    MarkerAnnotation(Identifier),
    module,
    ScopedIdentifier(Identifier, Identifier),
    ModuleBody),
  ModuleDeclaration(
    MarkerAnnotation(Identifier),
    open, module,
    ScopedIdentifier(Identifier, Identifier),
    ModuleBody))


# module with single element annotation

@Copyright("a")
module com.foo {}

==>

Program(
  ModuleDeclaration(
    Annotation(
      Identifier,
      AnnotationArgumentList(StringLiteral)),
    module,
    ScopedIdentifier(
      Identifier,
      Identifier),
    ModuleBody))


# package_declaration

package myVector;

==>

Program(PackageDeclaration(package,Identifier))

# module directive

module com.example.foo {
    requires com.example.foo.http;
}

==>

Program(
  ModuleDeclaration(module,
    ScopedIdentifier(
      ScopedIdentifier(
        Identifier,
        Identifier),
      Identifier),
    ModuleBody(
      ModuleDirective(requires,
        ScopedIdentifier(
          ScopedIdentifier(
            ScopedIdentifier(
              Identifier,
              Identifier),
            Identifier),
          Identifier)))))


# module directive with requires, exports, opens, uses and provides

module com.example.foo {
    requires com.example.http;
    requires java.logging;

    requires transitive com.example.network;

    exports com.example.bar;
    exports com.example.internal to com.example.probe;

    opens com.example.quux;
    opens com.example.internal to com.example.network, com.example.probe;

    uses com.example.Intf;
    provides com.example.Intf with com.example.Impl;
}

==>

Program(
  ModuleDeclaration(module,
    ScopedIdentifier(ScopedIdentifier(Identifier, Identifier), Identifier),
    ModuleBody(
      ModuleDirective(requires,
        ScopedIdentifier(ScopedIdentifier(Identifier, Identifier), Identifier)),
      ModuleDirective(requires,
        ScopedIdentifier(Identifier, Identifier)),
      ModuleDirective(requires, transitive,
        ScopedIdentifier(ScopedIdentifier(Identifier, Identifier), Identifier)),
      ModuleDirective(exports,
        ScopedIdentifier(ScopedIdentifier(Identifier, Identifier), Identifier)),
      ModuleDirective(exports,
        ScopedIdentifier(ScopedIdentifier(Identifier, Identifier), Identifier),
        to, ScopedIdentifier(ScopedIdentifier(Identifier, Identifier), Identifier)),
      ModuleDirective(opens,
        ScopedIdentifier(ScopedIdentifier(Identifier, Identifier), Identifier)),
      ModuleDirective(opens,
        ScopedIdentifier(ScopedIdentifier(Identifier, Identifier), Identifier),
        to, ScopedIdentifier(ScopedIdentifier(Identifier, Identifier), Identifier),
        ScopedIdentifier(ScopedIdentifier(Identifier, Identifier), Identifier)),
      ModuleDirective(uses,
        ScopedIdentifier(ScopedIdentifier(Identifier, Identifier), Identifier)),
      ModuleDirective(provides,
        ScopedIdentifier(ScopedIdentifier(Identifier, Identifier), Identifier),
        with, ScopedIdentifier(ScopedIdentifier(Identifier, Identifier), Identifier)))))


# single type import declaration

import java.util.Vector;

==>

Program(ImportDeclaration(import,
  ScopedIdentifier(ScopedIdentifier(Identifier, Identifier), Identifier)))


# type_import_on_declaraction

import java.util.*;

==>

Program(ImportDeclaration(import,
  ScopedIdentifier(Identifier, Identifier), Asterisk))


# single static import declaration

import static java.util.Vector;

==>

Program(ImportDeclaration(import, static,
  ScopedIdentifier(
    ScopedIdentifier(Identifier, Identifier),
    Identifier)))


# static import on demand declaration

import static java.util.*;

==>

Program(ImportDeclaration(import, static,
  ScopedIdentifier(Identifier, Identifier),
  Asterisk))


# class declaration

class Point {
}

==>

Program(
  ClassDeclaration(class, Definition, ClassBody))


# class declaration involving public, private, abstract and superclass

public class Point {
}

private class Point {
}

abstract class ColoredPoint extends Point {
}

==>

Program(
  ClassDeclaration(Modifiers(public), class, Definition, ClassBody),
  ClassDeclaration(Modifiers(private), class, Definition, ClassBody),
  ClassDeclaration(Modifiers(abstract), class, Definition, Superclass(extends, TypeName), ClassBody))


# class declaration with implements

public class Dog implements ISpeak {
}

==>

Program(
  ClassDeclaration(
     Modifiers(public), class, Definition,
     SuperInterfaces(implements,InterfaceTypeList(TypeName)), ClassBody))


# class declaration with body

class Point {
  int x;

  void bar() {
    x = 2;
  }
}

==>

Program(
  ClassDeclaration(class,
    Definition,
    ClassBody(
      FieldDeclaration(
        PrimitiveType,
        VariableDeclarator(Definition)),
      MethodDeclaration(
        void,
        Definition,
        FormalParameters,
        Block(
          ExpressionStatement(
            AssignmentExpression(Identifier, AssignOp, IntegerLiteral)))))))


# interface declaration

interface Top {
}

==>

Program(
  InterfaceDeclaration(
    interface,
    Definition,
    InterfaceBody))


# interface declaration with extends

interface Left extends Top {
}

interface Bottom extends Left, Right {}

==>

Program(
  InterfaceDeclaration(
    interface,
    Definition,
    ExtendsInterfaces(extends,InterfaceTypeList(TypeName)),
    InterfaceBody),
  InterfaceDeclaration(
    interface,
    Definition,
    ExtendsInterfaces(extends,InterfaceTypeList(TypeName, TypeName)), InterfaceBody))


# interface with annotation type declaration

@interface SelfRef {}

==>

Program(
  AnnotationTypeDeclaration(Identifier, AnnotationTypeBody))


# method declaration

class Beyonce {
  void calculateAnswer(double wingSpan, int numberOfEngines,
                       double length, double grossTons) {
      //do the calculation here
  }
}

==>

Program(
  ClassDeclaration(class,
    Definition,
    ClassBody(
      MethodDeclaration(
        void,
        Definition,
        FormalParameters(
          FormalParameter(PrimitiveType, Definition),
          FormalParameter(PrimitiveType, Definition),
          FormalParameter(PrimitiveType, Definition),
          FormalParameter(PrimitiveType, Definition)),
        Block(LineComment)))))


# constructor declaration

class Point {
  int x, y;
  Point(int x, int y) {
    this.x = x;
    this.y = y;
  }

  Point() {
    this(0, 0);
  }
}

==>

Program(
  ClassDeclaration(class,
    Definition,
    ClassBody(
      FieldDeclaration(
        PrimitiveType,
        VariableDeclarator(Definition),
        VariableDeclarator(Definition)),
      ConstructorDeclaration(
        Definition,
        FormalParameters(
          FormalParameter(
            PrimitiveType,
            Definition),
          FormalParameter(
            PrimitiveType,
            Definition)),
        ConstructorBody(
          ExpressionStatement(AssignmentExpression(
            FieldAccess(
              this,
              Identifier),
            AssignOp,
            Identifier)),
          ExpressionStatement(AssignmentExpression(
            FieldAccess(
              this,
              Identifier),
            AssignOp,
            Identifier)))),
      ConstructorDeclaration(
        Definition,
        FormalParameters,
        ConstructorBody(
          ExplicitConstructorInvocation(
            this,
            ArgumentList(
              IntegerLiteral,
              IntegerLiteral)))))))


# throws

class Beyonce {
  BufferedReader newReader() throws FileNotFoundException {
    new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));
  }
}

==>

Program(
  ClassDeclaration(class,
    Definition,
      ClassBody(
        MethodDeclaration(
          TypeName,
          Definition,
          FormalParameters,
          Throws(throws,TypeName),
          Block(
            ExpressionStatement(
              ObjectCreationExpression(new,
                TypeName,
                ArgumentList(
                  ObjectCreationExpression(new,
                    TypeName,
                    ArgumentList(
                      ObjectCreationExpression(new,
                        TypeName,
                        ArgumentList(Identifier)),
                      Identifier))))))))))


# object instantiation

class Point {
  public double Foo() {
    new BufferedWriter();
    Foo.new BufferedWriter();
  }
}

==>

Program(
  ClassDeclaration(class,
    Definition,
    ClassBody(
      MethodDeclaration(
        Modifiers(public),
        PrimitiveType,
        Definition,
        FormalParameters,
        Block(
          ExpressionStatement(
            ObjectCreationExpression(new,
              TypeName,
              ArgumentList)),
          ExpressionStatement(
            ObjectCreationExpression(
              Identifier, new,
              TypeName,
              ArgumentList)))))))


# variable declaration

class JayZ {
  public void Beyonce() {
    int blue_ivy_carter;
  };
}

==>

Program(
  ClassDeclaration(class,
    Definition,
    ClassBody(
      MethodDeclaration(
        Modifiers(public),
        void,
        Definition,
        FormalParameters,
        Block(
          LocalVariableDeclaration(
            PrimitiveType,
            VariableDeclarator(Definition)))))))


# enum declaration

enum HandSign {
   SCISSOR, PAPER, STONE
}

==>

Program(
  EnumDeclaration(enum,
    Definition,
    EnumBody(
      EnumConstant(Definition),
      EnumConstant(Definition),
      EnumConstant(Definition))))

# function declaration with default parameters - literals

function greet(String name = "World", Int count = 1) {
    return "Hello " & name & " (" & count & ")";
}

==>

Program(
  FunctionDeclaration(
    function,
    Definition,
    Arguments(
      Parameter(TypeName, Definition, AssignOp, StringLiteral),
      Parameter(TypeName, Definition, AssignOp, IntegerLiteral)
    ),
    Block(
      ReturnStatement(return, BinaryExpression(BinaryExpression(BinaryExpression(BinaryExpression(StringLiteral, StringConcatOp, Identifier), StringConcatOp, StringLiteral), StringConcatOp, Identifier), StringConcatOp, StringLiteral))
    )
  )
)


# function declaration with default parameters - expressions

function calculate(Numeric x, Numeric y = x * 2, Boolean debug = false) {
    if (debug) {
        writeOutput("Calculating: " & x & " + " & y);
    }
    return x + y;
}

==>

Program(
  FunctionDeclaration(
    function,
    Definition,
    FormalParameters(
      FormalParameter(TypeName, Definition),
      FormalParameter(TypeName, Definition, AssignOp, BinaryExpression(Identifier, ArithOp, IntegerLiteral)),
      FormalParameter(TypeName, Definition, AssignOp, BooleanLiteral)
    ),
    Block(
      IfStatement(if, ParenthesizedExpression(Identifier), Block(
        ExpressionStatement(MethodInvocation(MethodName(Identifier), ArgumentList(BinaryExpression(BinaryExpression(BinaryExpression(StringLiteral, StringConcatOp, Identifier), StringConcatOp, StringLiteral), StringConcatOp, Identifier))))
      )),
      ReturnStatement(return, BinaryExpression(Identifier, ArithOp, Identifier))
    )
  )
)


# function declaration with mixed default parameters

function processData(
    String data,
    String prefix = "[" & getCurrentDateTime() & "] ",
    Array options = [],
    Struct config = { verbose: true, timeout: 30 }
) {
    var result = prefix & data;
    if (config.verbose) {
        writeOutput(result);
    }
    return result;
}

==>

Program(
  FunctionDeclaration(
    function,
    Definition,
    FormalParameters(
      FormalParameter(TypeName, Definition),
      FormalParameter(TypeName, Definition, AssignOp, BinaryExpression(BinaryExpression(StringLiteral, StringConcatOp, MethodInvocation(MethodName(Identifier), ArgumentList())), StringConcatOp, StringLiteral)),
      FormalParameter(TypeName, Definition, AssignOp, ArrayLiteral()),
      FormalParameter(TypeName, Definition, AssignOp, StructLiteral(StructEntry(Identifier, BooleanLiteral), StructEntry(Identifier, IntegerLiteral)))
    ),
    Block(
      LocalVariableDeclaration(var, VariableDeclarator(Definition, AssignOp, BinaryExpression(Identifier, StringConcatOp, Identifier))),
      IfStatement(if, ParenthesizedExpression(FieldAccess(Identifier, Identifier)), Block(
        ExpressionStatement(MethodInvocation(MethodName(Identifier), ArgumentList(Identifier)))
      )),
      ReturnStatement(return, Identifier)
    )
  )
)


# function declaration with complex default expressions

function createUser(
    String username,
    String email = username & "@example.com",
    String role = getUserDefaultRole(),
    Date created = now(),
    Struct metadata = {
        source: "api",
        version: getAppVersion(),
        timestamp: getCurrentTimestamp()
    }
) {
    return {
        username: username,
        email: email,
        role: role,
        created: created,
        metadata: metadata
    };
}

==>

Program(
  FunctionDeclaration(
    function,
    Definition,
    FormalParameters(
      FormalParameter(TypeName, Definition),
      FormalParameter(TypeName, Definition, AssignOp, BinaryExpression(Identifier, StringConcatOp, StringLiteral)),
      FormalParameter(TypeName, Definition, AssignOp, MethodInvocation(MethodName(Identifier), ArgumentList())),
      FormalParameter(TypeName, Definition, AssignOp, MethodInvocation(MethodName(Identifier), ArgumentList())),
      FormalParameter(TypeName, Definition, AssignOp, StructLiteral(
        StructEntry(Identifier, StringLiteral),
        StructEntry(Identifier, MethodInvocation(MethodName(Identifier), ArgumentList())),
        StructEntry(Identifier, MethodInvocation(MethodName(Identifier), ArgumentList()))
      ))
    ),
    Block(
      ReturnStatement(return, StructLiteral(
        StructEntry(Identifier, Identifier),
        StructEntry(Identifier, Identifier),
        StructEntry(Identifier, Identifier),
        StructEntry(Identifier, Identifier),
        StructEntry(Identifier, Identifier)
      ))
    )
  )
)


# function with numeric default parameters

function mathOperation(
    Numeric a = 0,
    Numeric b = 1.5,
    String operation = "add",
    Boolean useFloatingPoint = true
) {
    switch (operation) {
        case "add":
            return a + b;
        case "multiply":
            return a * b;
        default:
            return 0;
    }
}

==>

Program(
  FunctionDeclaration(
    function,
    Definition,
    FormalParameters(
      FormalParameter(TypeName, Definition, AssignOp, IntegerLiteral),
      FormalParameter(TypeName, Definition, AssignOp, FloatingPointLiteral),
      FormalParameter(TypeName, Definition, AssignOp, StringLiteral),
      FormalParameter(TypeName, Definition, AssignOp, BooleanLiteral)
    ),
    Block(
      SwitchStatement(switch, ParenthesizedExpression(Identifier), SwitchBlock(
        SwitchLabel(case, StringLiteral),
        ReturnStatement(return, BinaryExpression(Identifier, ArithOp, Identifier)),
        SwitchLabel(case, StringLiteral),
        ReturnStatement(return, BinaryExpression(Identifier, ArithOp, Identifier)),
        SwitchLabel(default),
        ReturnStatement(return, IntegerLiteral)
      ))
    )
  )
)
